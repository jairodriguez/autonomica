"""
Content Templates Module

This module provides structured templates for different content types
to improve the quality and consistency of AI-generated content.
"""

from typing import Dict, List, Optional
from content_types_simple import ContentType, ContentFormat


class ContentTemplates:
    """Collection of content templates for different types and formats."""
    
    @staticmethod
    def get_blog_post_template() -> str:
        """Get template for blog post generation."""
        return """# {title}

## Introduction
{introduction}

## Main Content
{main_content}

## Conclusion
{conclusion}

## Call to Action
{call_to_action}

---
*Generated by Autonomica AI Content Generator*"""
    
    @staticmethod
    def get_tweet_template() -> str:
        """Get template for tweet generation."""
        return """{content}

{hashtags}"""
    
    @staticmethod
    def get_tweet_thread_template() -> str:
        """Get template for tweet thread generation."""
        return """Thread: {topic}

1/ {thread_intro}

2/ {thread_part_1}

3/ {thread_part_2}

4/ {thread_part_3}

5/ {thread_conclusion}

{hashtags}"""
    
    @staticmethod
    def get_facebook_post_template() -> str:
        """Get template for Facebook post generation."""
        return """{content}

{call_to_action}

{hashtags}"""
    
    @staticmethod
    def get_linkedin_post_template() -> str:
        """Get template for LinkedIn post generation."""
        return """{hook}

{content}

{insights}

{call_to_action}

{hashtags}"""
    
    @staticmethod
    def get_instagram_caption_template() -> str:
        """Get template for Instagram caption generation."""
        return """{caption}

{call_to_action}

{hashtags}"""
    
    @staticmethod
    def get_video_script_template() -> str:
        """Get template for video script generation."""
        return """VIDEO SCRIPT: {title}

HOOK (0-15 seconds):
{hook}

INTRODUCTION (15-30 seconds):
{introduction}

MAIN POINTS:
{main_points}

CONCLUSION (30 seconds):
{conclusion}

CALL TO ACTION (15 seconds):
{call_to_action}

---
Total Duration: {estimated_duration}
Target Audience: {target_audience}"""
    
    @staticmethod
    def get_carousel_template() -> str:
        """Get template for carousel content generation."""
        return """CAROUSEL: {title}

Slide 1: {slide_1_title}
{slide_1_content}

Slide 2: {slide_2_title}
{slide_2_content}

Slide 3: {slide_3_title}
{slide_3_content}

Slide 4: {slide_4_title}
{slide_4_content}

Slide 5: {slide_5_title}
{slide_5_content}

CONCLUSION:
{conclusion}

{hashtags}"""
    
    @staticmethod
    def get_email_newsletter_template() -> str:
        """Get template for email newsletter generation."""
        return """Subject: {subject_line}

{preheader}

Dear {greeting},

{main_content}

{footer}

---
{company_name}
{unsubscribe_link}"""
    
    @staticmethod
    def get_prompt_template(content_type: ContentType, format_type: ContentFormat = ContentFormat.PLAIN_TEXT) -> str:
        """Get the appropriate prompt template for a content type and format."""
        templates = {
            ContentType.BLOG_POST: ContentTemplates.get_blog_post_template,
            ContentType.TWEET: ContentTemplates.get_tweet_template,
            ContentType.TWEET_THREAD: ContentTemplates.get_tweet_thread_template,
            ContentType.FACEBOOK_POST: ContentTemplates.get_facebook_post_template,
            ContentType.LINKEDIN_POST: ContentTemplates.get_linkedin_post_template,
            ContentType.INSTAGRAM_CAPTION: ContentTemplates.get_instagram_caption_template,
            ContentType.VIDEO_SCRIPT: ContentTemplates.get_video_script_template,
            ContentType.CAROUSEL: ContentTemplates.get_carousel_template,
            ContentType.EMAIL_NEWSLETTER: ContentTemplates.get_email_newsletter_template,
        }
        
        template_func = templates.get(content_type)
        if template_func:
            return template_func()
        else:
            return "Generate {content_type} content about: {topic}"
    
    @staticmethod
    def get_formatting_instructions(content_type: ContentType, format_type: ContentFormat) -> str:
        """Get specific formatting instructions for content type and format."""
        instructions = {
            (ContentType.BLOG_POST, ContentFormat.MARKDOWN): """
- Use proper Markdown formatting
- Include headers, bullet points, and emphasis where appropriate
- Keep paragraphs concise (2-3 sentences)
- Use numbered lists for step-by-step content
- Include code blocks for technical content if relevant""",
            
            (ContentType.TWEET, ContentFormat.PLAIN_TEXT): """
- Keep within 280 character limit
- Use conversational tone
- Include relevant hashtags
- Make it engaging and shareable
- Use emojis sparingly but effectively""",
            
            (ContentType.VIDEO_SCRIPT, ContentFormat.PLAIN_TEXT): """
- Write in conversational, spoken language
- Include timing markers
- Use clear transitions between sections
- Keep sentences short and punchy
- Include visual cues in brackets [VISUAL: show chart]""",
            
            (ContentType.EMAIL_NEWSLETTER, ContentFormat.HTML): """
- Use HTML formatting for structure
- Include proper email-safe CSS
- Keep subject line under 50 characters
- Use preheader text effectively
- Include clear call-to-action buttons""",
        }
        
        return instructions.get((content_type, format_type), "")
    
    @staticmethod
    def get_quality_checklist(content_type: ContentType) -> List[str]:
        """Get quality checklist for specific content types."""
        checklists = {
            ContentType.BLOG_POST: [
                "Does the introduction hook the reader?",
                "Are main points clearly organized?",
                "Is there a strong conclusion?",
                "Does it include a clear call-to-action?",
                "Is the tone consistent throughout?",
                "Are there any grammar or spelling errors?",
                "Does it meet the target word count?",
                "Is the content valuable to the target audience?"
            ],
            
            ContentType.TWEET: [
                "Is it within 280 characters?",
                "Does it have a clear message?",
                "Are hashtags relevant and not excessive?",
                "Is it engaging and shareable?",
                "Does it match the brand voice?",
                "Is there a call-to-action if appropriate?"
            ],
            
            ContentType.VIDEO_SCRIPT: [
                "Is it written for spoken delivery?",
                "Are timing markers included?",
                "Does it flow logically?",
                "Is the hook compelling?",
                "Are transitions clear?",
                "Does it fit the target duration?",
                "Is there a strong call-to-action?"
            ],
            
            ContentType.EMAIL_NEWSLETTER: [
                "Is the subject line compelling?",
                "Does the preheader support the subject?",
                "Is the content scannable?",
                "Are there clear sections?",
                "Is the call-to-action prominent?",
                "Does it include unsubscribe option?",
                "Is it mobile-friendly?"
            ]
        }
        
        return checklists.get(content_type, [
            "Is the content relevant to the topic?",
            "Does it match the requested tone?",
            "Is it free of errors?",
            "Does it meet the format requirements?"
        ])
    
    @staticmethod
    def get_brand_voice_guidelines() -> Dict[str, str]:
        """Get common brand voice guidelines."""
        return {
            "professional": "Formal, authoritative, trustworthy, industry expertise",
            "conversational": "Friendly, approachable, casual, relatable",
            "innovative": "Forward-thinking, creative, cutting-edge, visionary",
            "authoritative": "Expert, confident, knowledgeable, reliable",
            "friendly": "Warm, welcoming, helpful, personable",
            "casual": "Relaxed, informal, easy-going, approachable",
            "luxury": "Sophisticated, premium, exclusive, refined",
            "tech": "Modern, innovative, efficient, cutting-edge"
        }
    
    @staticmethod
    def get_tone_modifiers() -> Dict[str, List[str]]:
        """Get tone modifiers for fine-tuning content tone."""
        return {
            "professional": ["authoritative", "confident", "expert", "reliable"],
            "conversational": ["friendly", "approachable", "casual", "relatable"],
            "enthusiastic": ["energetic", "passionate", "excited", "motivational"],
            "calm": ["serene", "peaceful", "tranquil", "soothing"],
            "urgent": ["immediate", "critical", "pressing", "time-sensitive"],
            "playful": ["fun", "entertaining", "amusing", "lighthearted"],
            "serious": ["grave", "solemn", "earnest", "thoughtful"],
            "inspirational": ["motivational", "uplifting", "encouraging", "aspirational"]
        }


class ContentTemplateEngine:
    """Engine for applying templates to generated content."""
    
    def __init__(self):
        self.templates = ContentTemplates()
    
    def apply_template(self, content: str, content_type: ContentType, 
                      format_type: ContentFormat, **kwargs) -> str:
        """Apply the appropriate template to generated content."""
        template = self.templates.get_prompt_template(content_type, format_type)
        
        # Extract key sections from content if it's structured
        sections = self._extract_sections(content, content_type)
        
        # Apply template with extracted sections and kwargs
        formatted_content = template
        for key, value in {**sections, **kwargs}.items():
            placeholder = "{" + key + "}"
            if placeholder in formatted_content:
                formatted_content = formatted_content.replace(placeholder, str(value))
        
        return formatted_content
    
    def _extract_sections(self, content: str, content_type: ContentType) -> Dict[str, str]:
        """Extract sections from structured content."""
        sections = {}
        
        # Simple section extraction based on common patterns
        lines = content.split('\n')
        current_section = None
        current_content = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # Check for section headers
            if line.lower().startswith(('introduction', 'intro', 'main', 'conclusion', 'summary')):
                if current_section and current_content:
                    sections[current_section] = '\n'.join(current_content).strip()
                current_section = line.lower().replace(':', '').replace(' ', '_')
                current_content = []
            elif current_section:
                current_content.append(line)
            else:
                # Default to main content if no section identified
                if 'main_content' not in sections:
                    sections['main_content'] = ''
                sections['main_content'] += line + '\n'
        
        # Add the last section
        if current_section and current_content:
            sections[current_section] = '\n'.join(current_content).strip()
        
        # Clean up main content
        if 'main_content' in sections:
            sections['main_content'] = sections['main_content'].strip()
        
        return sections
    
    def get_enhanced_prompt(self, base_prompt: str, content_type: ContentType,
                           format_type: ContentFormat, **kwargs) -> str:
        """Get an enhanced prompt with template and formatting instructions."""
        template = self.templates.get_prompt_template(content_type, format_type)
        formatting_instructions = self.templates.get_formatting_instructions(content_type, format_type)
        quality_checklist = self.templates.get_quality_checklist(content_type)
        
        enhanced_prompt = f"""
{base_prompt}

CONTENT TEMPLATE:
{template}

FORMATTING INSTRUCTIONS:
{formatting_instructions}

QUALITY CHECKLIST:
{chr(10).join(f"- {item}" for item in quality_checklist)}

Please generate content that follows the template and meets all quality requirements.
"""
        
        return enhanced_prompt.strip()


# Global template engine instance
template_engine = ContentTemplateEngine()


def get_template_engine() -> ContentTemplateEngine:
    """Get the global template engine instance."""
    return template_engine